<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/multisignatures.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/multisignatures.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

var async = require('async');
var crypto = require('crypto');
var extend = require('extend');
var genesisblock = null;
var Multisignature = require('../logic/multisignature.js');
var sandboxHelper = require('../helpers/sandbox.js');
var schema = require('../schema/multisignatures.js');
var sql = require('../sql/multisignatures.js');
var transactionTypes = require('../helpers/transactionTypes.js');

// Private fields
var modules, library, self, __private = {}, shared = {};

__private.assetTypes = {};

/**
 * Initializes library with scope content and generates a Multisignature instance.
 * Calls logic.transaction.attachAssetType().
 * @memberof module:multisignatures
 * @class
 * @classdesc Main multisignatures methods.
 * @param {function} cb - Callback function.
 * @param {scope} scope - App instance.
 * @return {setImmediateCallback} Callback function with `self` as data.
 */
// Constructor
function Multisignatures (cb, scope) {
	library = scope;
	genesisblock = library.genesisblock;
	self = this;

	__private.assetTypes[transactionTypes.MULTI] = library.logic.transaction.attachAssetType(
		transactionTypes.MULTI, new Multisignature()
	);

	setImmediate(cb, null, self);
}

// Public methods
/**
 * Gets transaction from transaction id and add it to sequence and bus.
 * @param {Object} tx - Contains transaction and signature.
 * @param {function} cb - Callback function.
 * @returns {setImmediateCallback} err messages| cb
 * @todo test function!.
 */
Multisignatures.prototype.processSignature = function (tx, cb) {
	var transaction = modules.transactions.getMultisignatureTransaction(tx.transaction);

	function done (cb) {
		library.balancesSequence.add(function (cb) {
			var transaction = modules.transactions.getMultisignatureTransaction(tx.transaction);

			if (!transaction) {
				return setImmediate(cb, 'Transaction not found');
			}

			modules.accounts.getAccount({
				address: transaction.senderId
			}, function (err, sender) {
				if (err) {
					return setImmediate(cb, err);
				} else if (!sender) {
					return setImmediate(cb, 'Sender not found');
				} else {
					transaction.signatures = transaction.signatures || [];
					transaction.signatures.push(tx.signature);
					transaction.ready = Multisignature.prototype.ready(transaction, sender);

					library.bus.message('signature', {transaction: tx.transaction, signature: tx.signature}, true);
					return setImmediate(cb);
				}
			});
		}, cb);
	}

	if (!transaction) {
		return setImmediate(cb, 'Transaction not found');
	}

	if (transaction.type === transactionTypes.MULTI) {
		transaction.signatures = transaction.signatures || [];

		if (transaction.asset.multisignature.signatures || transaction.signatures.indexOf(tx.signature) !== -1) {
			return setImmediate(cb, 'Permission to sign transaction denied');
		}

		// Find public key
		var verify = false;

		try {
			for (var i = 0; i &lt; transaction.asset.multisignature.keysgroup.length &amp;&amp; !verify; i++) {
				var key = transaction.asset.multisignature.keysgroup[i].substring(1);
				verify = library.logic.transaction.verifySignature(transaction, key, tx.signature);
			}
		} catch (e) {
			library.logger.error(e.stack);
			return setImmediate(cb, 'Failed to verify signature');
		}

		if (!verify) {
			return setImmediate(cb, 'Failed to verify signature');
		}

		return done(cb);
	} else {
		modules.accounts.getAccount({
			address: transaction.senderId
		}, function (err, account) {
			if (err) {
				return setImmediate(cb, 'Multisignature account not found');
			}

			var verify = false;
			var multisignatures = account.multisignatures;

			if (transaction.requesterPublicKey) {
				multisignatures.push(transaction.senderPublicKey);
			}

			if (!account) {
				return setImmediate(cb, 'Account not found');
			}

			transaction.signatures = transaction.signatures || [];

			if (transaction.signatures.indexOf(tx.signature) >= 0) {
				return setImmediate(cb, 'Signature already exists');
			}

			try {
				for (var i = 0; i &lt; multisignatures.length &amp;&amp; !verify; i++) {
					verify = library.logic.transaction.verifySignature(transaction, multisignatures[i], tx.signature);
				}
			} catch (e) {
				library.logger.error(e.stack);
				return setImmediate(cb, 'Failed to verify signature');
			}

			if (!verify) {
				return setImmediate(cb, 'Failed to verify signature');
			}

			library.network.io.sockets.emit('multisignatures/signature/change', transaction);
			return done(cb);
		});
	}
};

/**
 * Calls helpers.sandbox.callMethod().
 * @implements module:helpers#callMethod
 * @param {function} call - Method to call.
 * @param {} args - List of arguments.
 * @param {function} cb - Callback function.
 */
Multisignatures.prototype.sandboxApi = function (call, args, cb) {
	sandboxHelper.callMethod(shared, call, args, cb);
};

// Events
/**
 * Calls Multisignature.bind() with scope.
 * @implements module:multisignatures#Multisignature~bind
 * @param {scope} scope - Loaded modules.
 */
Multisignatures.prototype.onBind = function (scope) {
	modules = scope;

	__private.assetTypes[transactionTypes.MULTI].bind({
		modules: modules, library: library
	});
};

/**
 * Checks if `modules` is loaded.
 * @return {boolean} True if `modules` is loaded.
 */
Multisignatures.prototype.isLoaded = function () {
	return !!modules;
};

// Shared API
/**
 * @todo implement API comments with apidoc.
 * @see {@link http://apidocjs.com/}
 */
Multisignatures.prototype.shared = {
	getAccounts: function (req, cb) {
		var scope = {};

		async.series({
			validateSchema: function (seriesCb) {
				library.schema.validate(req.body, schema.getAccounts, function (err) {
					if (err) {
						return setImmediate(seriesCb, err[0].message);
					} else {
						return setImmediate(seriesCb);
					}
				});
			},
			getAccountIds: function (seriesCb) {
				library.db.one(sql.getAccountIds, { publicKey: req.body.publicKey }).then(function (row) {
					scope.accountIds = Array.isArray(row.accountIds) ? row.accountIds : [];
					return setImmediate(seriesCb);
				}).catch(function (err) {
					library.logger.error(err.stack);
					return setImmediate(seriesCb, 'Multisignature#getAccountIds error');
				});
			},
			getAccounts: function (seriesCb) {
				modules.accounts.getAccounts({
					address: { $in: scope.accountIds },
					sort: 'balance'
				}, ['address', 'balance', 'multisignatures', 'multilifetime', 'multimin'], function (err, accounts) {
					if (err) {
						return setImmediate(seriesCb, err);
					} else {
						scope.accounts = accounts;
						return setImmediate(seriesCb);
					}
				});
			},
			buildAccounts: function (seriesCb) {
				async.eachSeries(scope.accounts, function (account, eachSeriesCb) {
					var addresses = [];

					for (var i = 0; i &lt; account.multisignatures.length; i++) {
						addresses.push(modules.accounts.generateAddressByPublicKey(account.multisignatures[i]));
					}

					modules.accounts.getAccounts({
						address: { $in: addresses }
					}, ['address', 'publicKey', 'balance'], function (err, multisigaccounts) {
						if (err) {
							return setImmediate(eachSeriesCb, err);
						}

						account.multisigaccounts = multisigaccounts;
						return setImmediate(eachSeriesCb);
					});
				}, seriesCb);
			}
		}, function (err) {
			if (err) {
				return setImmediate(cb, err);
			} else {
				return setImmediate(cb, null, {accounts: scope.accounts});
			}
		});
	},

	pending: function (req, cb) {
		var scope = { pending: [] };

		async.series({
			validateSchema: function (seriesCb) {
				library.schema.validate(req.body, schema.pending, function (err) {
					if (err) {
						return setImmediate(seriesCb, err[0].message);
					} else {
						return setImmediate(seriesCb);
					}
				});
			},
			getTransactionList: function (seriesCb) {
				scope.transactions = modules.transactions.getMultisignatureTransactionList(false, false);
				scope.transactions = scope.transactions.filter(function (transaction) {
					return transaction.senderPublicKey === req.body.publicKey;
				});

				return setImmediate(seriesCb);
			},
			buildTransactions: function (seriesCb) {
				async.eachSeries(scope.transactions, function (transaction, eachSeriesCb) {
					var signed = false;

					if (transaction.signatures &amp;&amp; transaction.signatures.length > 0) {
						var verify = false;

						for (var i in transaction.signatures) {
							var signature = transaction.signatures[i];

							try {
								verify = library.logic.transaction.verifySignature(transaction, req.body.publicKey, transaction.signatures[i]);
							} catch (e) {
								library.logger.error(e.stack);
								verify = false;
							}

							if (verify) {
								break;
							}
						}

						if (verify) {
							signed = true;
						}
					}

					if (!signed &amp;&amp; transaction.senderPublicKey === req.body.publicKey) {
						signed = true;
					}

					modules.accounts.getAccount({
						publicKey: transaction.senderPublicKey
					}, function (err, sender) {
						if (err) {
							return setImmediate(cb, err);
						}

						if (!sender) {
							return setImmediate(cb, 'Sender not found');
						}

						var min = sender.u_multimin || sender.multimin;
						var lifetime = sender.u_multilifetime || sender.multilifetime;
						var signatures = sender.u_multisignatures || [];

						scope.pending.push({
							max: signatures.length,
							min: min,
							lifetime: lifetime,
							signed: signed,
							transaction: transaction
						});

						return setImmediate(eachSeriesCb);
					});
				}, function (err) {
					return setImmediate(seriesCb, err);
				});
			}
		}, function (err) {
			return setImmediate(cb, err, {transactions: scope.pending});
		});
	},

	sign: function (req, cb) {
		var scope = {};

		function checkGroupPermisions (cb) {
			var permissionDenied = (
			scope.transaction.asset.multisignature.keysgroup.indexOf('+' + scope.keypair.publicKey.toString('hex')) === -1
		);

			if (permissionDenied) {
				return setImmediate(cb, 'Permission to sign transaction denied');
			}

			var alreadySigned = (
			Array.isArray(scope.transaction.signatures) &amp;&amp;
			scope.transaction.signatures.indexOf(scope.signature.toString('hex')) !== -1
		);

			if (alreadySigned) {
				return setImmediate(cb, 'Transaction already signed');
			}

			return setImmediate(cb);
		}

		function checkTransactionPermissions (cb) {
			var permissionDenied = true;

			if (!scope.transaction.requesterPublicKey) {
				permissionDenied = (
				(!Array.isArray(scope.sender.multisignatures) || scope.sender.multisignatures.indexOf(scope.keypair.publicKey.toString('hex')) === -1)
			);
			} else {
				permissionDenied = (
				(scope.sender.publicKey !== scope.keypair.publicKey.toString('hex') || (scope.transaction.senderPublicKey !== scope.keypair.publicKey.toString('hex')))
			);
			}

			if (permissionDenied)  {
				return setImmediate(cb, 'Permission to sign transaction denied');
			}

			var alreadySigned = (scope.transaction.signatures &amp;&amp; scope.transaction.signatures.indexOf(scope.signature) !== -1);

			if (alreadySigned) {
				return setImmediate(cb, 'Transaction already signed');
			}

			return setImmediate(cb);
		}

		library.balancesSequence.add(function (cb) {
			async.series({
				validateSchema: function (seriesCb) {
					library.schema.validate(req.body, schema.sign, function (err) {
						if (err) {
							return setImmediate(seriesCb, err[0].message);
						} else {
							return setImmediate(seriesCb);
						}
					});
				},
				signTransaction: function (seriesCb) {
					scope.transaction = modules.transactions.getMultisignatureTransaction(req.body.transactionId);

					if (!scope.transaction) {
						return setImmediate(seriesCb, 'Transaction not found');
					}

					scope.hash = crypto.createHash('sha256').update(req.body.secret, 'utf8').digest();
					scope.keypair = library.ed.makeKeypair(scope.hash);

					if (req.body.publicKey) {
						if (scope.keypair.publicKey.toString('hex') !== req.body.publicKey) {
							return setImmediate(seriesCb, 'Invalid passphrase');
						}
					}

					scope.signature = library.logic.transaction.multisign(scope.keypair, scope.transaction);
					return setImmediate(seriesCb);
				},
				getAccount: function (seriesCb) {
					modules.accounts.getAccount({
						address: scope.transaction.senderId
					}, function (err, sender) {
						if (err) {
							return setImmediate(seriesCb, err);
						} else if (!sender) {
							return setImmediate(seriesCb, 'Sender not found');
						} else {
							scope.sender = sender;
							return setImmediate(seriesCb);
						}
					});
				},
				checkPermissions: function (seriesCb) {
					if (scope.transaction.type === transactionTypes.MULTI) {
						return checkGroupPermisions(seriesCb);
					} else {
						return checkTransactionPermissions(seriesCb);
					}
				}
			}, function (err) {
				if (err) {
					return setImmediate(cb, err);
				}

				var transaction = modules.transactions.getMultisignatureTransaction(req.body.transactionId);

				if (!transaction) {
					return setImmediate(cb, 'Transaction not found');
				}

				transaction.signatures = transaction.signatures || [];
				transaction.signatures.push(scope.signature);
				transaction.ready = Multisignature.prototype.ready(transaction, scope.sender);

				library.bus.message('signature', {transaction: transaction.id, signature: scope.signature}, true);
				library.network.io.sockets.emit('multisignatures/signature/change', transaction);

				return setImmediate(cb, null, {transactionId: transaction.id});
			});
		}, cb);
	},

	addMultisignature: function (req, cb) {
		var scope = {};

		library.balancesSequence.add(function (cb) {
			async.series({
				validateSchema: function (seriesCb) {
					library.schema.validate(req.body, schema.addMultisignature, function (err) {
						if (err) {
							return setImmediate(seriesCb, err[0].message);
						} else {
							return setImmediate(seriesCb);
						}
					});
				},
				addMultisignature: function (seriesCb) {
					scope.hash = crypto.createHash('sha256').update(req.body.secret, 'utf8').digest();
					scope.keypair = library.ed.makeKeypair(scope.hash);

					if (req.body.publicKey) {
						if (scope.keypair.publicKey.toString('hex') !== req.body.publicKey) {
							return setImmediate(seriesCb, 'Invalid passphrase');
						}
					}

					modules.accounts.setAccountAndGet({publicKey: scope.keypair.publicKey.toString('hex')}, function (err, account) {
						if (err) {
							return setImmediate(seriesCb, err);
						}

						if (!account || !account.publicKey) {
							return setImmediate(seriesCb, 'Account not found');
						}

						if (account.secondSignature &amp;&amp; !req.body.secondSecret) {
							return setImmediate(seriesCb, 'Invalid second passphrase');
						}

						scope.secondKeypair = null;

						if (account.secondSignature) {
							scope.secondHash = crypto.createHash('sha256').update(req.body.secondSecret, 'utf8').digest();
							scope.secondKeypair = library.ed.makeKeypair(scope.secondHash);
						}

						try {
							scope.transaction = library.logic.transaction.create({
								type: transactionTypes.MULTI,
								sender: account,
								keypair: scope.keypair,
								secondKeypair: scope.secondKeypair,
								min: req.body.min,
								keysgroup: req.body.keysgroup,
								lifetime: req.body.lifetime
							});
						} catch (e) {
							return setImmediate(seriesCb, e.toString());
						}

						modules.transactions.receiveTransactions([scope.transaction], true, seriesCb);
					});
				}
			}, function (err) {
				if (err) {
					return setImmediate(cb, err);
				} else {
					library.network.io.sockets.emit('multisignatures/change', scope.transaction);
					return setImmediate(cb, null, {transactionId: scope.transaction.id});
				}
			});
		}, cb);
	}
};

// Export
module.exports = Multisignatures;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-accounts.html">accounts</a></li><li><a href="module-app.html">app</a></li><li><a href="module-blocks.html">blocks</a></li><li><a href="module-dapps.html">dapps</a></li><li><a href="module-delegates.html">delegates</a></li><li><a href="module-helpers.html">helpers</a></li><li><a href="module-helpers.module_helpers_diff.html">helpers/diff</a></li><li><a href="module-helpers.module_helpers_httpApi.html">helpers/httpApi</a></li><li><a href="module-helpers.module_helpers_slots.html">helpers/slots</a></li><li><a href="module-loader.html">loader</a></li><li><a href="module-multisignatures.html">multisignatures</a></li><li><a href="module-peers.html">peers</a></li><li><a href="module-rounds.html">rounds</a></li><li><a href="module-server.html">server</a></li><li><a href="module-signatures.html">signatures</a></li><li><a href="module-transactions.html">transactions</a></li><li><a href="module-transport.html">transport</a></li></ul><h3>Classes</h3><ul><li><a href="Crypto.html">Crypto</a></li><li><a href="Field.html">Field</a></li><li><a href="Migrator.html">Migrator</a></li><li><a href="module-accounts.Account.html">Account</a></li><li><a href="module-accounts.Accounts.html">Accounts</a></li><li><a href="module-accounts.AccountsHttpApi.html">AccountsHttpApi</a></li><li><a href="module-blocks.Block.html">Block</a></li><li><a href="module-blocks.BlockReward.html">BlockReward</a></li><li><a href="module-blocks.Blocks.html">Blocks</a></li><li><a href="module-blocks.BlocksHttpApi.html">BlocksHttpApi</a></li><li><a href="module-dapps.DApp.html">DApp</a></li><li><a href="module-dapps.DApps.html">DApps</a></li><li><a href="module-dapps.DappsHttpApi.html">DappsHttpApi</a></li><li><a href="module-dapps.InTransfer.html">InTransfer</a></li><li><a href="module-dapps.OutTransfer.html">OutTransfer</a></li><li><a href="module-delegates.Delegate.html">Delegate</a></li><li><a href="module-delegates.Delegates.html">Delegates</a></li><li><a href="module-delegates.DelegatesHttpApi.html">DelegatesHttpApi</a></li><li><a href="module-helpers.BigNumber.html">BigNumber</a></li><li><a href="module-helpers.Inserts.html">Inserts</a></li><li><a href="module-helpers.RoundChanges.html">RoundChanges</a></li><li><a href="module-helpers.Sequence.html">Sequence</a></li><li><a href="module-helpers.Validator.html">Validator</a></li><li><a href="module-helpers.z_schema.html">z_schema</a></li><li><a href="module-loader.Loader.html">Loader</a></li><li><a href="module-loader.LoaderHttpApi.html">LoaderHttpApi</a></li><li><a href="module-multisignatures.Multisignature.html">Multisignature</a></li><li><a href="module-multisignatures.Multisignatures.html">Multisignatures</a></li><li><a href="module-multisignatures.MultisignaturesHttpApi.html">MultisignaturesHttpApi</a></li><li><a href="module-peers.Peer.html">Peer</a></li><li><a href="module-peers.Peers.html">Peers</a></li><li><a href="module-peers.PeersHttpApi.html">PeersHttpApi</a></li><li><a href="module-rounds.Round.html">Round</a></li><li><a href="module-rounds.Rounds.html">Rounds</a></li><li><a href="module-server.Server.html">Server</a></li><li><a href="module-server.ServerHttpApi.html">ServerHttpApi</a></li><li><a href="module-signatures.Signature.html">Signature</a></li><li><a href="module-signatures.Signatures.html">Signatures</a></li><li><a href="module-signatures.SignaturesHttpApi.html">SignaturesHttpApi</a></li><li><a href="module-transactions.Transaction.html">Transaction</a></li><li><a href="module-transactions.TransactionPool.html">TransactionPool</a></li><li><a href="module-transactions.Transactions.html">Transactions</a></li><li><a href="module-transactions.TransactionsHttpApi.html">TransactionsHttpApi</a></li><li><a href="module-transactions.Transfer.html">Transfer</a></li><li><a href="module-transport.Broadcaster.html">Broadcaster</a></li><li><a href="module-transport.Transport.html">Transport</a></li><li><a href="module-transport.TransportHttpApi.html">TransportHttpApi</a></li><li><a href="Sql.html">Sql</a></li><li><a href="System.html">System</a></li><li><a href="Vote.html">Vote</a></li></ul><h3>Events</h3><ul><li><a href="module-app.html#~event:cleanup">cleanup</a></li><li><a href="module-app.html#~event:exit">exit</a></li><li><a href="module-app.html#~event:SIGINT">SIGINT</a></li><li><a href="module-app.html#~event:SIGTERM">SIGTERM</a></li><li><a href="module-app.html#~event:uncaughtException">uncaughtException</a></li></ul><h3>Namespaces</h3><ul><li><a href="-__private.html">__private</a></li><li><a href="module-helpers.constants.html">constants</a></li><li><a href="module-helpers.ed.html">ed</a></li><li><a href="module-helpers.exceptions.html">exceptions</a></li><li><a href="module-helpers.module_helpers_httpApi-middleware.html">middleware</a></li><li><a href="module-helpers.module_helpers_slots.html">helpers/slots</a></li></ul><h3>Global</h3><ul><li><a href="global.html#afterSave">afterSave</a></li><li><a href="global.html#aggregateBlocksReward">aggregateBlocksReward</a></li><li><a href="global.html#applyBlock">applyBlock</a></li><li><a href="global.html#applyGenesisBlock">applyGenesisBlock</a></li><li><a href="global.html#applyLimits">applyLimits</a></li><li><a href="global.html#applyTransaction">applyTransaction</a></li><li><a href="global.html#checkTransaction">checkTransaction</a></li><li><a href="global.html#count">count</a></li><li><a href="global.html#deleteAfterBlock">deleteAfterBlock</a></li><li><a href="global.html#deleteBlock">deleteBlock</a></li><li><a href="global.html#deleteLastBlock">deleteLastBlock</a></li><li><a href="global.html#generateBlock">generateBlock</a></li><li><a href="global.html#getBlockProgressLogger">getBlockProgressLogger</a></li><li><a href="global.html#getById">getById</a></li><li><a href="global.html#getCommonBlock">getCommonBlock</a></li><li><a href="global.html#getIdSequence">getIdSequence</a></li><li><a href="global.html#getLastBlock">getLastBlock</a></li><li><a href="global.html#isLoaded">isLoaded</a></li><li><a href="global.html#lastReceipt">lastReceipt</a></li><li><a href="global.html#list">list</a></li><li><a href="global.html#loadBlocksData">loadBlocksData</a></li><li><a href="global.html#loadBlocksFromPeer">loadBlocksFromPeer</a></li><li><a href="global.html#loadBlocksOffset">loadBlocksOffset</a></li><li><a href="global.html#loadBlocksPart">loadBlocksPart</a></li><li><a href="global.html#loadLastBlock">loadLastBlock</a></li><li><a href="global.html#onBind">onBind</a></li><li><a href="global.html#onReceiveBlock">onReceiveBlock</a></li><li><a href="global.html#popLastBlock">popLastBlock</a></li><li><a href="global.html#processBlock">processBlock</a></li><li><a href="global.html#promiseTransactions">promiseTransactions</a></li><li><a href="global.html#readDbRows">readDbRows</a></li><li><a href="global.html#receiveBlock">receiveBlock</a></li><li><a href="global.html#recoverChain">recoverChain</a></li><li><a href="global.html#sandboxApi">sandboxApi</a></li><li><a href="global.html#saveBlock">saveBlock</a></li><li><a href="global.html#saveGenesisBlock">saveGenesisBlock</a></li><li><a href="global.html#shared">shared</a></li><li><a href="global.html#validateForce">validateForce</a></li><li><a href="global.html#verifyBlock">verifyBlock</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Thu May 11 2017 11:47:30 GMT-0300 (ART)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
